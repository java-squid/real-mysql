## MySQL 엔진 아키텍처

> - MySQL 엔진, 스토리지 엔진으로 구성된다.
> - 스토리지 엔진은 InnoDB, MyISAM이 있다.

![MySQL Architecture](./MySQL%20Architecture.png)

## MySQL 엔진 구성요소

> - 커넥션 핸들러 : 클라이언트의 접속, 쿼리 요청을 처리
> - SQL 파서
> - 전처리기
> - 옵티마이저

## 스토리지 엔진

- 전달 된 쿼리 요청을 처리
  - 구체적으로는 디스크 I/O 작업을 담당
- 캐시, 버퍼를 내부에 가지고 있음
  - 처리 성능 향상

## 핸들러 API

- MySQL 엔진이 요청을 받아서 전처리 후 스토리지 엔진에 포워딩 하는데, 이 때 사용되는 API
  - MySQL 엔진이 스토리지 엔진에게 요청하기 위해 사용하는 인터페이스

```sql
> SHOW GLOBAL STATUS LIKE 'Handler%';
```

---

## MySQL 스레딩 구조

- MySQL 서버는 스레드 기반으로 동작
  - => 책에 언급된 내용인데, 특별한 내용인걸까? (스레드 기반으로 동작 안하는 프로세스가 있는걸까...?)
- Foreground / Background 스레드로 나뉘어진다.
- 스레드 목록은 다음의 쿼리로 확인 가능

```sql
> SELECT thread_id, name, type, processlist_user, processlist_host
  FROM performance_schema.threads ORDER BY type, thread_id;
```

### Foreground Thread

- 클라이언트의 요청을 처리하는 스레드
- 커넥션 수만큼 존재한다.
  - 커넥션 종료 시 스레드 캐시(스레드 풀 같은 개념인 듯)에 반납
  - 반납 시 스레드 캐시가 설정 수 이상으로 대기 스레드를 보유하게 되는 경우, 종료시켜버린다.
- 버퍼, 캐시로부터 데이터를 읽어서 처리한다.
- 버퍼, 캐시는 포그라운드 스레드가 처리하지만, 디스크에 대한 작업은 스토리지 엔진마다 다르다.
  - MyISAM : 디스크 작업까지 foreground thread가 처리
  - InnoDB : 디스크 작업은 background thread에 위임

> **스레드 캐시**
>
> - MySQL은 기본적으로 클라이언트 요청 시 포그라운드 스레드를 새로 생성한다.
> - 스레드 캐시는 스레드 생성으로 인한 비용을 줄이기 위해 '대기 상태' 의 스레드를 일정 수 만큼 유지하도록 캐시 해두는 것.

### Background Thread

- Insert Buffer 병합 스레드
  > **Insert Buffer** (...🤔)
  >
  > - 현재는 Change Buffer로 명명
  > - DML (INSERT, UPDATE, DELETE)을 버퍼에 캐시하고 있다가, 읽기 요청에 의해 해당 데이터들이 디스크로부터 로드될 때 병합하는 것
  >   - 이렇게 버퍼에 계속 가지고 있다가 모아서 디스크에 플러시 하는 듯.
  >   - 디스크 I/O를 줄이기 위함
  > - 🤔..................
- 로그를 디스크에 쓰는 스레드
- 버퍼 풀 데이터를 디스크에 쓰는 스레드
- 디스크로부터 버퍼로 데이터를 읽는 스레드
- 잠금, 데드락 모니터링 스레드

---

## 메모리 할당 및 사용구조

### 글로벌 영역

- OS가 할당
- 모든 스레드에 의해 공유

### 로컬 영역

- MySQL 프로세스에 의해 관리
- 스레드마다 독립된 메모리 영역
  - 자바 플랫폼 스레드가 사용하는 스레드 로컬 같은 것일까...?
  - Sort Buffer
  - Join Buffer
  - ...

---

## 쿼리 실행 구조

### 쿼리 파서

- 요청 받은 쿼리문을 MySQL에서 식별할 수 있는 최소단위로 분해하여 트리 형태로 저장
- 문법 검사 수행

### 전처리기

- 파서가 만들어낸 트리로 쿼리 구조 유효성 검사
- 접근 권한 검사 수행

### 옵티마이저

- 쿼리문을 가장 효율적으로 처리할 수 있는 방법을 결정

### 실행 엔진

- 옵티마이저의 결정(실행 계획)에 대한 처리를 스토리지 엔진에 위임

> **실행엔진 -> 스토리지 엔진 예시**
>
> 1. 임시 테이블을 만들도록 요청
> 2. WHERE 절 조건에 해당되는 레코드를 읽어오도록 요청
> 3. 2에서 읽은 레코드를 임시테이블에 저장할 것을 요청
> 4. 임시 테이블에서 필요한 방식으로 데이터를 읽어 오도록 요청 (Order by 같은 처리...)
> 5. 사용자 또는 다른 모듈로 결과 전달

### 스토리지 엔진 (핸들러)

- 실행 엔진으로부터의 요청 처리 (데이터 읽기 / 쓰기)

---

## 스레드 풀

- 정해진 수 만큼의 스레드만 사용하도록 함
- 처리할 수 있는 요청 수를 제한하여 CPU 처리의 집약도를 높일 수 있음
  - 스케쥴링 될 스레드 수를 줄여서 컨텍스트 스위칭으로 인한 오버헤드를 줄일 수 있음

---

## 트랜잭션 지원 메타데이터

> **메타데이터**
>
> - 테이블, 스토어드 프로시저 정보

- 기존에는 메타데이터를 파일로 관리하여 일관성이 유지되지 않는 문제가 있었음
  - 트랜잭션 미지원 때문인데, 만약 처리 도중 비정상 종료되면 메타데이터가 일부만 유실되는 문제 발생
- 8.0부터는 시스템 관련 테이블, 메타데이터 모두 InnoDB 테이블에 저장
