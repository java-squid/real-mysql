## InnoDB

- 레코드 기반 잠금 기능을 제공하여 동시성 처리에 뛰어난 성능을 보인다.

### 프라이머리키 클러스터링

- 모든 레코드는 프라이머리 키를 기준으로 클러스터링 되는데, 세컨더리 인덱스는 프라이머리 키를 논리적 주소로 사용한다.
- 디스크에 프라이머리 키 순으로 저장되기 때문에 좋은 퍼포먼스를 보장할 수 있다.
  - 다른 인덱스보다 옵티마이저에 의해 선택 될 확률이 높다.

### 외래키 지원

- MyISAM과 달리 외래키를 지원한다.
- 부모 테이블과 자식 테이블 모두 외래키로 사용되는 컬럼에 인덱스 생성이 필요하다.
- 데이터를 수정하거나 지울 때 데이터 존재여부 체크가 필요하여 잠금이 발생하고, 각 테이블에 전파될 수 있다.
  - `foreign_key_checks` 값을 설정하면 외래키 제약조건에 의한 실행 실패를 어느정도는 배제할 수 있다고 함
    - 외래키 제약조건으로 최근 불편함을 겪은적이 있음

### MVCC (Multi Version Concurrency Control)

- 잠금 없는 일관된 읽기를 제공하기 위한 목적
- Undo 로그를 사용
- 데이터를 변경하는 시나리오는 다음의 절차로 처리한다. (Member 로우 변경)
  1.  UPDATE 쿼리 실행
  2.  Undo 로그에 업데이트 이전 로우 데이터 복사
  3.  InnoDB 버퍼에 업데이트 될 내용 적용
  4.  Commit or Rollback
      - Commit
        a. InnoDB 버퍼풀에 저장된 변경내용을 디스크에 플러시
      - Rollback
        a. Undo 로그에 백업했던 데이터를 InnoDB 버퍼풀로 복사
        b. Undo 로그 삭제 (단, 해당 로그를 참조하는 트랜잭션이 없을 때)
- 데이터를 읽는 시나리오는 트랜잭션 격리수준에 따라 다르다.
  - ~ REPEATABLE_READ : Undo 로그에 있는 데이터를 읽는다.
  - READ_COMMITED ~ : InnoDB 버퍼풀에 있는 내용을 읽는다.
- 이전에 정리했던 #MVCC 참고

### 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

- InnoDB 스토리지 엔진이 제공하는 MVCC에 의해 SERIALIZABLE 미만의 격리수준에서는 레코드 락 없이 일관된 읽기가 가능하다.
- **그러나 MVCC에 장점만 있는 것은 아니다.**
  - 만약 트랜잭션을 길게 가져갈 경우 언두 로그에 많은 데이터가 쌓일 수 있다.
  - 언두 로그를 삭제하지 못하고 유지하기 위해 리소스를 많이 소모하게 될 수 있다.

### 데드락 감지

- 데드락에 의해 처리가 지연되거나 막히는 것을 감지하기 위해 잠금 대기 목록을 관리한다.
  - 데드락 감시를 위한 별도의 스레드를 관리한다
- 데드락 감시 스레드가 데드락이 발생한 트랜잭션을 발견하면, 그 중 하나를 종료시킨다.
  - 롤백 시 후처리를 위한 리소스 소모가 적은 순으로 정리한다.
  - **즉, 언두 로그의 양이 적은 트랜잭션 순으로 정리된다.**
- 데드락 감지는 기본적으로 record 레벨에서만 동작한다.
  - 만약 테이블까지 감지하려면 `innodb_table_locks` 라는 변수를 활성화 해야하낟.

### 장애 복구 자동화

- MySQL 서버가 재시작 될 때 자동으로 동작
- 만약 자동 복구가 안되는 경우, `innodb_force_recovery` 설정을 활성화 해야 함
  - `innodb_force_recovery` 값은 1~6까지 설정 가능 (클수록 심각한 장애상황)

## InnoDB Buffer Pool

- 데이터 캐시 공간
- 데이터 변경(INSERT, UPDATE, DELETE) 전 버퍼의 역할도 한다.
  - 버퍼에 모았다가 한번에 처리하기 때문에 디스크 랜덤 I/O를 줄일 수 있다.

### 버퍼 풀 크기 설정

- 버퍼에 할당 될 메모리 외에 OS, MySQL서버의 다른 기능에 의해 점유 될 공간도 고려해야 함
- 버퍼 풀은 청크 단위로 관리 됨 (128MB)
  - 늘리거나 줄이는 것도 청크 단위
- 버퍼 풀 내부에 분할된 인스턴스를 관리하고, 인스턴스 단위로 세마포어 설정 가능
  - Memory가 여유롭다면 인스턴스 단위를 작게 가져가는 것이 성능상 유리할 수 있음

### 버퍼 풀 구조

- LRU List
  - New List(MRU) + Old List (LRU)
- Flush List
  - 디스크 동기화 이전의 데이터 페이지를 관리하는 자료구조
  - 데이터 변경 시 디스크 내부 리두 로그에 기록하고, 리두 로그의 레코드는 해당 데이터가 포함된 페이지 주소 값을 가짐 (?) (Real MySQL p.111 - 아직 완벽하게 이해 못한 듯...)
- Free List

### InnoDB의 데이터 읽기 방식

- 과정
  1.  데이터 페이지가 버퍼풀에 있는지 확인
      - 해당 페이지 포인터를 MRU 방향으로 이동시킴
  2.  없으면 데이터 페이지를 디스크로부터 읽어와서 적재
      - LRU 헤더에 포인터 저장
- 만약 자주 읽히는 데이터가 있다면 해당 인덱스를 어댑티드 해시 인덱스라는 자료구조에 별도 저장함.
- InnoDB 버퍼풀에는 페이지단위로 데이터를 불러온다.
  - 클린페이지 + 더티페이지

### Redo Log

- MySQL은 Commit이 발생해도 바로 디스크에 동기화가 되지는 않는다.
- InnoDB는 데이터 페이지의 변경 내역을 Redo 로그라는 것에 계속 기록하여 장애 발생 시 복구용으로 사용한다.
- 리두 로그 파일은 정해진 크기로 관리되며, 계속 업데이트 됨
  - 재사용 되지만 LSN이라는 고유 값은 계속 늘어나는 방식을 취함
- 체크포인트 : 리두 로그, 더티 페이지의 내용이 디스크로 플러시 되는 시점
- 활성 리두 로그 : 가장 최신의 체크 포인트 이후 관리되고 있는 리두 로그들
  - 체크포인트가 발생한 시점의 LSN 이후의 리두 로그들
- 체크 포인트 에이지 : 체크 포인트 LSN ~ 활성 리두 로그의 마지막 LSN

### Double Write Buffer

- MySQL은 페이지 단위로 데이터를 읽고 쓴다.
- Redo로그는 페이지의 변경 내용만 기록된다.
- 만약 시스템 오류로인해 더티 페이지들을 디스크 파일로 플러시 할 때, 일부 페이지만 디스크에 반영된다면 다른 페이지는 복구할 수 없다.
- 이 문제를 예방하기 위해 디스크 테이블 스페이스에 Double Write Buffer를 두고있다.
- 더티 페이지들 전체를 테이블 스페이스에 우선 기록하고, 이후 페이지 하나씩 디스크에 반영한다.
  - 만약 중간에 문제가 발생하면 여기서 복구한다.

## Change Buffer

- 레코드가 INSERT, UPDATE 될 때 변경사항을 임시 저장하는 메모리 공간
- INSERT, UPDATE는 인덱스에 접근하는 랜덤 I/O가 발생하는데, 이를 줄이기 위함
- 대상 테이블에서 UNIQUE 인덱스를 사용하는 경우에는 필히 확인이 필요하기 때문에 이 버퍼를 사용할 수 없다.

## Adaptive Hash Index

- 클라이언트가 자주 검색하는 데이터를 별도로 저장하는 해두는 인덱스
- InnoDB 스토리지 엔진에 의해 자동으로 관리된다.
- 저장되는 데이터는 데이터 페이지의 포인터이다.
  - InnoDB 버퍼풀에서의 메모리 주소
- 스토리지 엔진 내 단 하나만 존재하여 이 곳에서 모든 인덱스에 관한 데이터를 다룬다.
