## InnoDB 스토리지 엔진 잠금
- 레코드 기반의 잠금 방식
- MySQL엔진 과 별도의 잠금 방식이 이원화 되어있어서 MySQL명령을 통해 접근하기가 까다로움
- 이전에는 InnoDB의 잠금 정보를 보기 까다로웠지만 최근 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAIT` 라는 테이블을 조인 해서 조회하면 어떤 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있고, 장시간 잠금을 가지고 있는 클라이언트를 찾아서 종료 시킬수도 있다.
- InnoDB의 중요도가 높아짐에 따라 `Performance Schema`를 이용해 InnoDB 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링 방법도 추가되었다.

### 1-1. 레코드락
- 레코드 자체만을 잠그는 것
- 다른 상용 DBMS의 레코드 락과 동일한 역할은 한다.
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금.
- 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정.

### 1-2. 갭락
- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것.
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것.

### 1-3. 넥스트 키 락
- 레코드 락과 갭 락을 합쳐 놓은 형태
- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버는 REPEATABLE READ 격리 수준을 사용해야 한다.
- `innodb_locks_unsafe_for_binlog` 시스템 변수가 비활성화 되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다
- 갭 락과 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
- 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다. 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

### 1-4. 자동 증가 락
- AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 하기 때문에 InnoDB 엔진에서는 테이블 수준의 내부적으로 AUTO_INCREMENT 잠금을 사용한다
- INSERT, REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE, DELETE등의 쿼리에서는 걸리지 않는다.
- 트랜잭션과 상관없없이 AUTO_INCREMENT값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.
- 테이블에 단 하나만 존재하기 때문에 락이 걸리면 나머지 쿼리는 대기하게 된다(AUTO_INCREMENT 컬럼에 값을 명시적으로 설정하더라도 자동 증가 락을 걸게 된다)

### 2. 인덱스와 잠금
- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리 된다. 
- 레코드가 변경 될때 인덱스가 동일한 모든 레코드가 잠기게 된다.
- UPDATE를 위한 인덱스가 적절히 준비되어 있지 않다면 각 클라이언트 간 동시성이 상당히 떨어져서 한 세션에서 UPDATE 작업을 진행 하면 다른 클라이언트는 그 테이블을 업데이트하지 못하고 대기하는 상황이 발생할 것이다.
- 테이블에 인덱스가 존재하지 않는다면 테이블을 풀스캔 하면서 모든 레코드를 잠그게 된다.

### 3. 레코드 수준의 잠금 확인 및 해제
- 테이블 잠금에서는 잠금의 대상이 테이블 자체이므로 쉽게 문제의 원인이 발견되고 해결될 수 있지만, InnoDB의 레코드 수준의 잠금은 테이블의 각 레코드에 잠금이 걸리기 때문에 잠금이 걸린 레코드가 자주 사용되지 않는다면 잠겨진 상태로 잘 발견되지 않는다.
- 이전 버전의 MySQL서버에서는 잠금에 대한 메타 정보(딕셔너리 테이블)을 제공하지 않았지만 5.1 버전 이후부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능하다.
- 잠금을 해제하려면 KILL 명령을 이용해 MySQL 서버의 프로세스를 강제로 종료하면 된다.
