> 인덱스 키 값의 크기

- B-tree 가 자식노드를 몇개 갖는 지는 인덱스의 [[page]] 크기, 키 값의 크기에 따라 결정됨
	- `innodb_page_size`, 4~64kb
		- 기본값, 16kb

![image](https://velog.velcdn.com/images/rg970604/post/79e9715c-07e0-4541-9cdf-684af0329638/image.png)

- 하나의 인덱스 [[page]]  (16kb) 에는 몇 개의 키를 저장할 수 있을까?
	- 자식노드는 12byte
	- 1kb = 1024 byte
	- 16 * 1024 / 16 + 12 = 585
- 정리해보다면 SELECT 쿼리가 500개 레코드를 읽어야 한다?
	- 인덱스 한 페이지로 가능
	- 그 이상이라면 2번 이상 디스크로부터 읽어야함.
	- 인덱스 키 값이 커지면, 디스크로 부터 **읽어야하는 횟수**가 늘어난다. (그만큼 느려진다)
- 즉 인덱스 키 값은 짦은게 좋을듯 하다

> B-tree 깊이

- 깊이는 제어할 방법이 없음
- 깊이가 3인 경우, 최대 몇 개의 키 값을 가질 수 있는가?
	- 585 * 585 * 585 = 2억.. (키가 16byte 인 경우)
	- 32byte로 늘어나면 5천만개(372 * 372 * 372) 로 줄어듬
- 결론
	- 키 값이 커지면 커질 수록, 하나의 인덱스 페이지에 담을 수 있는 갯수가 적어지고, 깊이가 깊어지므로 디스크 읽기가 더 많이 필요해진다

> 선택도 (기수성)

- Selectivity (Cardinality)
- 모든 인덱스 키 값 가운데 유니크한 값의 수
	- 예를 들어, 전체 인덱스 키 값이 100, 그 중 유니크한 값이 10이라면, Selectivity (Cardinality) 는 10이다.
- 인덱스 키 값 중에 중복된 값이 많아지면 Selectivity (Cardinality) 는 떨어진다 (낮아지고)
- 인덱스는 Selectivity (Cardinality) 가 높을수록 검색 대상이 줄기 때문에 그만큼 빠르게 처리된다.

> 읽어야 하는 레코드의 건수

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.
	- 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이, 테이블에서 직접 레코드 1건을 읽는 것보다 **4~5배**정도 비용이 더 많이 드는 작업이라 예측함.
	- 즉 인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블 레코드의 20~25% 넘어서면 인덱스를 이용하지 않고, 모든 테이블을 읽어서 필터링 하는게 더 효율적

---
## Reference
 -  [Real MySQL 8.0 (1권)](https://product.kyobobook.co.kr/detail/S000001766482)
	- 8.3.3 B-tree 인덱스 사용에 영향을 미치는 요소
	- 8.3.3.3 선택도(기수성)