## 클러스터링 인덱스
- InnoDB 엔진에서만 지원함. 
- 테이블의 프라이머리 키에 대해서만 적용되는 내용이며 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 프라이머리키 값에 의해 레코드의 저장 위치가 결정된다는 것.
- 프라이머리 키 값이 변경되면 레코드의 물리적인 저장 위치가 변경되어야 한다.
- 파라이머리 키 값으로 클러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 큼
- 클러스터링 인덱스 := 클러스터링 테이블 으로 사용되기도 함
- InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르지만, 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.
- 일반 B-Tree와 비슷한 구조이긴 하지만 세컨더리 인덱스를 위한 B-Tree의 리프노드와는 다르게 클러스터링 인덱스 리프 노드에는 레코드의 모든 커럼이 같이 저장되어 있음.
- 프라이머리 키나 유니크 인덱스가 없는 InnoDB테이블에서는 아무 의미없는 숫자 값으로 클러스터링 됨. 따라서 가능하면 프라이머리 키를 명시적으로 생성하여 테이블당 단 하나만 가질 수 있는 혜택을 누리도록 하자
> 클러스터링 테이블 구성 단계
> 1. 프라이멀 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
> 2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX)중에서 첫 번째 인덱스를 클러스터링 키로 선택
> 3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택

### 세컨더리 인덱스에 미치는 영향
- MyISAM, MEMORY 엔진을 사용하는 테이블은 INSERT될 때 처음 저장된 공간에서 절대 이동하지 않는다.
- MyISAM, MEMORY 엔진에서는 프라이멀키와 센컨더리 인덱스는 구조적으로 아무런 차이가 없다.
- InnoDB테이블에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면, 클러스터링 키 값이 변경 될 때마다 데이터 레코드의 주소가 변경되고 테이블의 모든 인덱스에 저장된 주소값을 변경해야한다. 따라서 InnoDB 세컨더리 인덱스는 프라이머리 키 값을 저장되도록 구현되어 있음.

### 클러스터링 인덱스의 장점과 단점
- 빠르다, 느리다
- 같은 온라인 트랜잭션 환경에서는 쓰기와 읽기의 비율이 2:8 , 1:9정도이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는것이 중요함

### 클러스터링 테이블 사용 시 주의사항
- 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키)값을 포함한다.
- 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커지게 됨.
- 일반적으로 테이블의 세컨더리 인덱스가 4~5개 정도 생성되는 것을 고려하면 세컨더리 인덱스 크기가 급격히 증가하는 경우가 발생
- 가능하다면 AUTO_INCREMENT보다는 업무적인 컬럼을 프라이머리 키로 생성하는 것이 좋음
- 프라이머리 키는 AUTO_INCREMENT 컬럼을 이용해서라도 생성하는 것이 낫다

