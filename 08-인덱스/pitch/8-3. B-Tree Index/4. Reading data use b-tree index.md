## B-Tree 인덱스를 통한 데이터 읽기
- 인덱스를 사용할지 못하게할지 판단하기 위해선 각 스토리지 엔진이 어떻게 인덱스를 이용해서 실제 레코드를 읽어내는지 알고 있어야 함.

### 인덱스 레인지 스캔
- 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식
- 루트노드 -> 브랜치노드 -> 리프노드 진행하여 시작할 위치를 탐색하여 데이터를 스캔하고 끝나는 위치에 다다르면 지금까지 읽은 레코드를 반환하고 쿼리를 종료함.
- 실제로 인덱스만 읽는 경우와 리프 노드들을 스캔하면서 실제 데이터 파일의 레코드를 읽어와야 하는 경우도 존재함.
- 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요함. 리프노드에 저장된 레코드 주소로 데이터 파일을 읽어오는데 이 때 건단위로 랜덤 I/O가 발생
- 커버링 인덱스
    - 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들어 성능이 빨라진다.

### 인덱스 풀 스캔
- 인덱스를 사용하지만 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 함.
- 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
  - ex) `인덱스 (A, B, C)` 일 때 쿼리의 조건절이 B 혹은 C 컬럼으로 검색하는 경우
- 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 뒤 인덱스의 리프 노드를 연결하는 링크드 리스트를 따라서 처음부터 끝까지 스캔하는 방식
- 인덱스 레인지 스캔보다 빠르지 않지만 테이블 풀 스캔 보다는 효율적
- 인덱스를 사용하지만 효율적인 방식은 아니고 일반적으로 인덱스를 생성하는 목적은 아니다

### 루스 인덱스 스캔
- MySQL 8.0 버전 이후 부터 다른 DBMS에서 지원하는 인덱스 스킵 스캔과 같은 최적화를 지원하기 시작함
- 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미 함.
- 인덱스 레인지 스캔과 비슷하게 동작하지만 중간에 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다.
- 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX(), MIN() 함수에 대해 최적화를 하는 경우에 사용된다.

### 인덱스 스킵 스캔
- 결합 컬럼 인덱스의 첫 컬럼이 조건 절에 있지 않아도 인덱스를 이용할 수 있는 방식
- 인덱스 스킵 스캔 기능이 비활성화 되어 있으면 실행 계획 `type = index` 로 인덱스 풀스캔이 이루어짐
- 제약조건
  - WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야함
  - 쿼리가 인덱스에 존재하는 컬럼만으로 처리가 가능해야 함