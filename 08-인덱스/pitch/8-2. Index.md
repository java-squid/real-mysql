## 인덱스
- 데이터 파일의 검색 성능 향상을 위해 {컬럼: 레코드 주소} 형식으로 인덱스를 만들어 둠
- `SortedList` 형식으로 이루어짐
    - 데이터가 저장될 때 마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느림
    - 하지만 이미 정렬되어 있어 조회시에는 빠른 성능을 보임
    |SortedList|ArraryList|
    |---|---|
    |항상 정렬된 상태로 유지|저장되는 순서 그대로 유지|
    
- 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 데이터의 읽기 속도를 높이는 기능
- 그렇다고 무분별하게 인덱스를 생성한다면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 역효과를 불러올 수 있음

### 인덱스 분류
- 프라이머리 키
    - 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스
    - 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 식별자라고 불리기도 함
    - 프라이머리 키는 NULL과 중복을 허용하지 않는다.
- 세컨더리 인덱스
    - 프라이머리 키를 제외한 나머지 모든 인덱스
- 유니크 인덱스
    - 프라이머리 키와 성격이 유사하고 프라이머리 키를 대체해서 사용이 가능함
    - 대체 키라고도 함
    - 인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만 옵티마이저 입장에서는 상당히 중요한 문제가 됨.
        - equal 검색으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 냄
    

### 데이터 저장 방식
- B-Tree
    - 일반적으로 사용되는 인덱스 알고리즘
    - 컬럼의 값을 변경하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
    - MySQL 서버에서는 위치기반 검색을 지원하기 위한 R-Tree 알고리즘도 B-Tree 알고리즘의 응용으로 볼 수 있다.
- Hash
    - 컬럼의 값으로 해시값을 계산하여 인덱싱하는 알고리즘
    - 변형된 값으로 인덱싱하기 때문에 일부/범위 검색에는 해시 인덱스를 사용할 수 없음
    - 주로 메모리 기반 데이터베이스에서 많이 사용됨
    <!--메모리 기반 데이터베이스 뭐가있나?-->
