## 옵티마이저란?

- 데이터 분포를 계산하여 최적의 실행계획을 수립하는 컴포넌트

## 쿼리 실행 순서

1. 요청된 쿼리를 파싱
   - SQL 파서가 수행
   - 파싱된 쿼리는 트리 구조로 저장 (SQL Parse Tree)
2. 파싱한 쿼리를 분석하여 인덱스, 테이블 선정
   - 불필요한 연산 단순화
   - 조인이 있다면 어떤 순서로 테이블을 사용할지
   - 인덱스 선정
   - 임시 테이블 사용 여부 결정
3. `2.`에서 선정한 인덱스, 테이블을 가지고 스토리지 엔진에 요청

## 옵티마이저의 종류

### 규칙 기반 최적화

- 데이터 분포를 고려하지 않고 옵티마이저 내부에 내장된 규칙에 따라 실행 계획 수립

## 비용 기반 최적화

- 여러 실행 계획을 세우고 작업 비용, 데이터 분포 등을 계산하여 최적의 방법을 선택

## 기본 데이터 처리

### 풀 테이블 스캔

- 데이터가 적어서 인덱스 없이 직접 다 읽는 것이 효과적인 경우
- 조건 중 인덱스를 활용할 수 있는 값이 없는 경우
- 인덱스 레인지 스캔보다 효율적인 경우

### 풀 인덱스 스캔

- 인덱스를 처음부터 끝까지 다 읽는 것
- `SELECT COUNT(*) FROM table;` 과 같은 쿼리를 실행 할 때, 풀 인덱스 스캔을 이용한다.
  - 용량이 작은 인덱스를 선택함으로서 디스크 읽기를 줄일 수 있기 때문
- `SELECT * FROM table;` 같은 쿼리는 이용 불가 함

### 리드 어헤드

- 미래에 필요할 것을 예상하여 조회 대상이 아닌 데이터를 미리 가져오는 것
- 데이터 검색이 발생할 때 연속된 데이터 페이지를 읽는 방식

## Using filesort (ORDER BY)

- 실행 계획의 `Extra` 컬럼에 `Using filesort` 표시
- 인덱스를 사용하지 못하는 경우에 발생
- 인덱스가 없다는 것은 정렬이 되어 있지 않다는 것으로, 쿼리 실행 시점에 별도의 정렬 과정이 필요하므로 처리가 느리다.
- 데이터 양이 적으면 메모리에 올려서 정렬하므로 충분히 빠르다.

#### Sort Buffer

- 정렬을 위해 할당 받는 메모리 공간
  - 정렬 해야 할 레코드 수에 따라 가변적
- 레코드가 많아서 하나의 Sort Buffer로 부족한 경우, 여러번으로 나누어 정렬해야 한다. 과정 중간마다 정렬된 결과에 대한 디스크 쓰기가 발생하여 전체 속도가 저하된다.

#### Multi-merge

- 디스크 쓰기가 발생할 때에는 이전 정렬 결과와 합쳐서 재정렬을 해야하는데, 이 과정을 멀티머지라 한다.

#### 싱글 패스 정렬

- SELECT 대상이 되는 모든 컬럼을 Sort Buffer에 포함하여 정렬

#### 투 패스 정렬

- 정렬 대상 컬럼, PK만으로 Sort Buffer에 정렬
- 정렬한 뒤 PK를 가지고 테이블로부터 SELECT 컬럼을 다시 조회
- BLOB, TEXT 컬럼이 포함되면 투 패스 정렬이 수행된다.

### 임시 테이블

- 임시 테이블을 사용하지 않는 정렬 쿼리는 다음의 동작을 한다.
  - 드라이빙 테이블만을 가지고 WHERE절로 범위를 좁힌다.
  - 좁혀진 범위에 대해 정렬을 수행한다.
  - 정렬된 결과에 드리븐 테이블을 조인한다.
- 조인이 발생한 쿼리에 드라이빙 테이블만을 이용해서 정렬할 수 없는 경우
  - Ex) 드리븐 테이블의 컬럼이 정렬 조건에 들어가 있는 경우
- 조인 결과를 임시 테이블에 저장한 뒤 정렬을 수행한다.
  - `Using temporary; Using filesort`

### GROUP BY 처리

- ORDER BY와 마찬가지로 드라이빙 테이블에 속한 컬럼만으로 GROUP BY를 수행하는 경우, 임시 테이블을 사용하지 않는다.

#### 루스 인덱스 스캔을 이용한 GROUP BY

- `Using index for group-by`

**완벽하게 이해가 안되니 외우자**

```sql
SELECT emp_no
FROM salaries
WHERE from_date = '1985-03-01'
GROUP BY emp_no
```

1. (emp_no, from_date) 인덱스를 차례로 스캔하면서 emp_no의 첫 번째 유일한 값 `10001` 을 찾아낸다.
2. (emp_no, from_date) 인덱스에서 emp_no가 '10001' 인 것 중 from_date 값이 '1985-03-01'인 레코드만 검색
3. (emp_no, from_date) 인덱스에서 emp_no의 그 다음 유니크한 값을 가져온다.
4. `3.` 에서 결과가 없다면 종료, 있다면 `2.` 부터 다시 수행

#### 임시 테이블을 이용한 GROUP BY

- MySQL 8.0부터는 필요한 경우 GROUP BY 컬럼들을 UNIQUE INDEX로 갖는 임시 테이블을 만들어서 그루핑 수행
