### 풀 테이블 스캔과 풀 인덱스 스캔
- 옵티마이저는 다음과 같은 조건일 때 풀 테이블 스캔을 진행함
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다  풀 테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
  - WHERE 절이나 ON절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

- 일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 대부분의 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있음.
- MyISAM 스토리지 엔진은 풀 테이블 스캔시 디스크로부터 페이지를 하나씩 읽어옴
- InnoDB엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 `리드 어헤드(Read ahead)`작업이 자동으로 시작됨.
  > - 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어서 InnoDB 버퍼 풀에 가져다 두는것
  > - 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드(Foreground thread, 클라이언트 스레드)가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다
  > - 백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가 시킴.
  > - 최대 한번에 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장하고, 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리된다.
  > - `innodb_read_ahead_threshold`변수로 리드 어헤드의 임계값을 설정할 수 있음.(연속된 데이터 페이지가 읽히는 개수)
  > - 데이터 웨어하우스용으로 사용한다면 옵션 값을 더 낮은 값으로 설정해서 더 빨리 리드 어헤드가 시작되게 유도하는 것도 좋은 방법
  > - 리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용된다.
  >>- 아래 쿼리는 아무 조건없이 레코드 건수를 조회하고 있으므로 당연히 풀 테이블 스캔이 발생할 것 처럼 보이지만 풀 인덱스 스캔을 할 가능성이 높다.  
  >>   ```sql
  >>   SELECT COUNT(*) FROM RANDOM_TABLE
  >>   ```
  >>- MySQL 서버는 단순히 레코드의 건수만 필요로 하는 쿼리라면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄일 수 있기 때문
  >>- 일반적으로 인덱스는 테이블의 2~3개 컬럼만으로 구성되기 때문에 테이블 자체보다는 용량이 작아서 빠른 처리가 가능하다.
  >>    ```sql
  >>    SELECT * FROM RANDOM_TABLE
  >>    ```
  >>- 위 쿼리 처럼 레코드에 있는 컬럼이 필요한 쿼리의 경우에는 풀 인덱스 스캔을 활용하지 못하고 풀 테이블 스캔을 진행한다.
