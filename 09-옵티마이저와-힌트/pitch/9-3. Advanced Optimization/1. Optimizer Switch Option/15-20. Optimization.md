## 컨디션 팬아웃(condition_fanout_filter)
- 조인을 실행할 때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미친다. 따라서 옵티마이저는 여러 테이블이 조인되는 경우 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행한다.
- WHERE 조건절에 사용된 컬럼에 대해 인덱스가 있는경우, 히스토그램이 존재하는 경우 옵티마이저는 해당 조건을 만족하는 레코드의 비율을 계산할 수 있다.
> 실행계획 수립시 선택하는 순서
> 1. 레인지 옵티마이저를 이용한 예측
> 2. 히스토그램을 이용한 예측
> 3. 인덱스 통계를 이용한 예측
> 4. 추측에 기반한 예측
> 레인지 옵티마이저는 실제 인덱스의 데이터를 살펴보고 레코드 건수를 예측하는 방식인데, 실제 쿼리가 실행되기도 전에 실행 계획을 수립 단계에서 빠르게 소량의 데이터를 읽어보는 것이다. 레인지 옵티마이저에 의한 예측은 인덱스를 이용해서 쿼리가 실행될수 있을 때만 사용된다. 레인지 옵티마이저를 이용한 예측이 히스토그램이나 인덱스의 통계 정보보다 우선순위가 높기 때문에 실행계획에 표시되는 레코드 건수가 테이블이나 인덱스의 통계, 히스토그램 정보와 다른 값이 표시될 수도 있다.


## 파생 테이블 머지(derived_merge)
- FROM절에 사용된 서브쿼리는 먼저 실행해서 그 결과를 임시 테이블로 만든 다음 외부 쿼리 부분을 처리하고 FROM절에 사용된 서브쿼리를 파생 테이블(Derived Table)이라고 부른다. 실행 계획 select_type에 `DERIVED`로 표시됨
- 내부적으로 생성되는 임시테이블은 처음에는 메모리에 생성되지만, 임시 테이블에 저장될 레코드 건수가 많아지면 결국 디스크로 다시 기록되어야 하고 이는 임시 테이블로 레코드를 복사하고 읽는 오버헤드로 인해 쿼리 성능이 저하된다.
- derived_merge 최적화 옵션은 위에 단점들을 보완하가 위해 도입된 최적화이다. derived_merge를 사용한 최적화를 사용할 시 실행계획에 `DERIVED`였던 부분이 없어지고 옵티마이저가 서브쿼리부분을 외부쿼리로 병합하여 단순 조회 계획으로 바뀌게 된다.
> 최적화 제한사항
> 항상 옵티마이저가 자동으로 서브쿼리를 외부쿼리로 병합할 수 없다.
> 아래와 같은 상황에서는 서브쿼리를 외부 쿼리로 수동으로 병합해서 작성하는게 쿼리 성능 향상에 도움이 된다.
> - SUM(), MIN(), MAX()같은 집계 함수와 윈도우 함수(Window Function)사용된 서브쿼리
> - DISTINCT가 사용된 서브쿼리
> - GROUP BY나 HAVING이 사용된 서브쿼리

## 인비저블 인덱스(use_invisible_indexes)
- 이전에는 인덱스가 존재하면 항상 옵티마이저가 실행 계획을 수립할 때 해당 인덱스를 검ㅌ토하고 사용했다. MySQL 8.0 버전 부터는 인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어하는 기능을 제공한다.
- `use_invisible_indexes` 옵티마이저 옵션을 이용하면 INVISIBILE로 설정된 인덱스라 하더라도 옵ㅌ티마이저가 사용하게 제어할 수 있다.

## 스킵 스캔(skip_scan)
- 인덱스를 구성하는 컬럼의 순서가 매우 중요하고, 쿼리에 따라 해당 인덱스를 사용할 수 있을지 없을지 나뉘게 된다. 인덱스 스킵 스캔은 제한적이긴 하지만 인덱스의 이런 제약 사항을 뛰어넘을 수 있는 최적화 방법이다.
- 인덱스의 선행 컬럼이 조건절에 사용되지 않더라도 후행 컬럼의 조건만으로도 인덱스를 이용한 쿼리 성능 개선이 가능하다.
- 하지만 인덱스의 선행 컬럼이 매우 다양한 값을 가지는 경우에는 인덱스 스킵 스캔 최적화가 비효율 적일 수 있다. 그래서 MySQL 옵티마이저는 인덱스의 선행 컬럼이 소수의 유니크한 값을 가질때만 인덱스 스킵 스캔 최적화를 사용한다.

## 해시 조인(hash_join)
- 해시 조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지만 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않는다. 따라서 해시 조인은 최고 스루풋(Best Throughput)전략에 적합하다.
- 일반 적인 웹서비스는 온라인 트랜잭션(OLTP)서비스이기 때문에 스루풋도 중요하지만 응답 속도가 더 중요하다. 그리고 분석과 같은 서비스는 사용자의 응답 시간보다는 전체적으로 처리 소요 시간이 중요하기 때문에 응답 속도보다는 전체 스루풋이 중요하다
- MySQL 8.0.17 버전까지는 해시 조인 기능이 없어 조인 조건이 좋지 않은 경우 블록 네스티드 루프 조인 알고리즘을 사용했다. 블록 네스티드 루프 조인도 쿼리의 조인 조건이 인덱스를 제대로 활용할 수 없는 경우에만 사용되는 최적화 방법 수준으로 사용되어 잘 설계된 인덱스를 가진 데이터베이스에서는 블록 네스티드 루프 조인 실행 계획은 거의 볼 수 없다.
- 그래서 이후 동등 조인을 위해 해시 조인이 사용되었지만 안티 조인이나 세미 조인을 위해서는 블록 네스티드 루프 조인이 사용되었다. 하지만 MySQL 8.0.20버전부터는 블록 네스티드 루프 조인은 더이상 사용되지 않고 네스티드 루프 조인을 사용할 수 없는 경우에는 항상 해시 조인이 사용되도록 바뀌었다.
- 8.0.20 버전부터는 `block_nested_loop` 같은 `optimizer_switch` 또는 BNL과 NO_BNL 같은 힌트들도 해시 조인을 유도하는 목적으로 사용된다
- 해시 조인은 빌드 단계와 프로브 단계로 나뉘어 처리된다.
  - 빌드 단계: 조인 대상 테이블 중에서 레코드 건수가 적어서 해시 테이블로 만들기에 용이한 테이블을 골라서 메모리에 해시 테이블을 생성(빌드)하는 작업을 수행한다. 빌드 단계에서 해시 테이블을 만들 때 사용되는 원본 테이블을 빌드 테이블이라고도 한다.
  - 프로브 단계: 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는 과정을 의미한다. 이 때 읽는 나머지 테이블을 프로브 테이블이라고도 한다.
  하지만 실행계획에서는 빌드 테이블과 프로브 테이블을 식별하기 어려워 `EXPLAIN FORMAT=TREE`, `EXPLAIN ANALYZE` 명령을 통해 좀더 쉽게 구분할 수 있다.


## 인덱스 정렬 선호(prefer_ordering_index)
- MySQL 옵티마이저는 ORDER BY 또는 GROUP BY를 인덱스를 사용해 처리 가능한 경우 쿼리의 실행 계획에서 인덱스의 가중치를 높이 설정해서 실행된다.
- 옵티마이저가 항상 최적의 결과를 선택하는 것이 아니여서 비효율 적으로 실행 계획을 선택할 가능성도 존재한다.
- 8.0.20 버전까지는 다른 실행 계획을 사용하게 하기 위해 특정 인덱스(ORDER BY를 위한 인덱스)를 사용하지 못하도록 `IGNORE INDEX`힌트를 사용하거나 했지만 8.0.21 버전부터는 ORDER BY를 위한 인덱스에 너무 가중치를 부여하지 않도록 `prefer_ordering_index` 옵티마이저 옵션이 추가됐다.

