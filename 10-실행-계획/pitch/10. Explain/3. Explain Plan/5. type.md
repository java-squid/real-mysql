## type 컬럼
- MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.(인덱스, 풀 테이블 스캔...)
- 일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 실행 계획에서 체크해야할 중요한 정보
- 하나의 단위 SELECT 쿼리는 접근 방식 중에서 단 하나만 사용이 가능하다.
- 실행 계획의 각 라인에 접근 방법이 2개 이상 표시되지 않으며, `index_merge`이외의 `type`에서는 인덱스 항목에도 단 하나의 인덱스 이름만 표시된다.
- 아래에 정리된 `type`에 표시될 수 있는 값들은 성능이 빠른 순서대로 나열하였다.

### system
- 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법
- MyISAM, MEMORY 테이블에서만 사용되는 접근 방법
- 실제 어플리케이션에서 사용되는 쿼리에서는 거의 보이지 않는 실행 계획

### const
- 테이블의 레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리 처리 방식
- 다른 DBMS에서는 이를 유니크 인덱스 스캔(UNIQUE INDEX SCAN)이라고도 표현한다
- 다중 컬럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 컬럼만 조건으로 사용할 때는 사용할 수 없다
- MySQL의 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화 하여 실행 계획의 `type`이 `const(상수)`로 표시되는 것이다.

### eq_ref
- 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
- 조인에서 처음 읽은 테이블의 컬럼값을, 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용
- 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법

### ref
- 인덱스의 종류와 관계없이 동등(Equal)조건으로 검색할 때 사용된다.
- eq_ref와 달리 조인의 순서와 관계없이 사용되며 프라이머리 키나 유니크 키등의 제약 조건도 없다.
- 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 `const`, `eq_ref`보다는 빠르지 않다.

```txt
const, eq_ref, ref 모두 WHERE 조건절에 사용하는 비교 연산자는 동등 비교 연산자여야 한다. ("=", "<=>")
```

### fulltext
- MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법
- 일반적으로 쿼리에 전문 검색 조건(MATCH ... AGAINST ...)을 사용하면 MySQL서버는 주저없이 fulltext 접근 방법을 사용한다.
- 전문 검색 인덱스를 이용하는 것보다 일반 인덱스를 이용하는 range 접근 방법이 더 빨리 처리되는 경우가 많이 있으므로 전문 검색 쿼리를 사용할 때는 조건별로 성능을 확인해 보는 편이 좋다.

### ref_or_null
- NULL 비교가 추가된 ref 접근 방법
- 실제 업무에서 많이 활용되지 않지만, 만약 사용된다면 나쁘지 않은 접근 방법

### unique_subquery
- WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법
- 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.

### index_subquery
- IN 연산자의 특성상 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거돼야 한다.
- 서브쿼리 결과의 중복된 값을 인덱스를 이용해서 제거할 수 있을 때 사용된다.
>unique_subquery vs index_subquery
>- unique_subquery: IN (subquery) 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않음
>- index_subquery: IN (subquery) 형태의 조건에서 subquery의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음

### range
- 인덱스 레인지 스캔 형태의 접근 방법
- 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미하고 주로 `<, >, IS NULL, BETWEEN, IN, LIKE`등의 연산자를 이용해 인덱스를 검색할 때 사용된다.
- 얼마나 많은 레코드를 필요로 하느냐에 따라 차이는 있겠지만 `range`접근 방법도 상당히 빠르며 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.
```txt
일반적으로 const, ref, range 세가지 접근 방법을 모두 묶어서 인덱스 레인지 스캔이라고 언급한다.
```

### index_merge
- 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후 그 결과를 병합해서 처리하는 방식
- 여러 인덱스를 읽어야 하므로 일반적으로 range접근 방법보다 효율성이 떨어진다.
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다
- index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요하다

### index
- 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미함
- 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같지만 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔시 풀 테이블 스캔보다 빠르게 처리되고 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있어서 훨씬 효율적이다
- 다음 조건 가운데(첫번째 + 두번째), (첫번째 + 세번째) 조건을 충족하는 쿼리에서 사용되는 읽기 방식
  - range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
  - 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우(즉, 데이터 파일을 읽지 않아도 되는 경우)
  - 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우(즉, 별도의 정렬 작업을 피할 수 있는 경우)
- LIMIT 조건이 있을 경우에는 효율적일 수 있으나, 가져와야 할 레코드 건수가 많아지면 상당히 느린 처리를 수행한다.

### ALL
- 인덱스를 사용하지 않고 테이블을 처음부터 끝까지 읽어서 레코드를 가져오는 풀 테이블 스캔 접근 방법을 의미한다.
- 대용량의 레코드를 처리하는 쿼리에서는 잘못 튜닝된 쿼리보다는 나은 접근 방법
- 쿼리를 튜닝한다는 것이 무조건 인덱스 풀 스캔이나 테이블 풀 스캔을 사용하지 못하게 하는 것이 아니라는 것을 기억해야 한다.
- 일반적으로 웹서비스등과 같은 환경에서는 적합하지 않다.
- 대량의 디스크 I/O를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어 들이는 기능을 제공하고 InnoDB에서는 이 기능을 `리드 어헤드(Read Ahead)`라고 한다

> 리드 어헤드
> - MySQL 서버에서는 인접한 페이지가 연속해서 몇 번 읽히면 백그라운드로 작동하는 읽기 스레드가 최대 64개의 페이지씩 한꺼번에 디스크로부터 읽어 들이기 때문에 한번에 페이지 하나씩 읽어 들이는 작업보다는 상당히 빠르게 레코드를 읽을 수 있다.
> - `innodb_read_ahead_threshold`, `innodb_random_read_ahead` 변수를 이용해 리드 어헤드를 제어할 수 있다.
> - 8.0버전에서는 병렬 쿼리(Parallel Query)기능이 도입됐는데, 초기 구현단계여서 조건없이 전체 테이블 건수를 가져오는 쿼리 정도만 병렬로 실행할 수 있다. MySQL 서버의 병렬 쿼리는 `innodb_parallel_read_threads`변수를 이용해 동시에 사용할 수 있는 스레드를 제어할 수 있다.